using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ContentServer.Core.Conversion
{
    public static class ConversionPipelineExtensions
    {
        internal static bool ValidateFormat(
            this ConversionPipeline pipeline,
            IReadOnlyDictionary<string, ConversionAction> actions,
            out FileDefinition? output,
            out string? description)
        {
            output = null;
            description = null;
            Dictionary<string, FileDefinition> inputs = new Dictionary<string, FileDefinition>(pipeline.Inputs);
            HashSet<string> usedInput = new HashSet<string>();
            HashSet<string> usedOutput = new HashSet<string>();
            foreach (var item in pipeline.Steps)
            {
                ConversionDefinition conversion = item.Conversion;

                if (!item.Validate(out description))
                {
                    description = "Conversion {conversion.Name}. " + description;
                    return false;
                }

                if (!actions.ContainsKey(conversion.Name))
                {
                    description = $"Conversion {conversion.Name}. Not registered";
                    return false;
                }

                if (!usedOutput.Add(item.Output))
                {
                    description = $"Conversion {conversion.Name}. Output alias {item.Output} already used by another conversion.";
                    return false;
                }

                ConversionAction action = actions[conversion.Name];

                if (item.Input.Count < action.MinInputCount || item.Input.Count > action.MaxInputCount)
                {
                    description = $"Conversion {action.Name}. Expected {action.MinInputCount} - {action.MaxInputCount} input files. {item.Input.Count} was provided";
                    return false;
                }

                foreach (var inp in item.Input)
                {
                    if (inputs.ContainsKey(inp))
                    {
                        if (!action.InputFormats.Contains(inputs[inp].Format))
                        {
                            description = $"Conversion {conversion.Name}. Input file with alias {inp}. Format {inputs[inp]} not supported.";
                            return false;
                        }

                        foreach (var v in conversion.Values)
                        {
                            if (!action.SupportedParams.ContainsKey(v.Key))
                            {
                                description = $"Conversion {conversion.Name}. Parameter with name {v.Key}. Not supported.";
                                return false;
                            }

                            string? validation = action.SupportedParams[v.Key].Invoke(v.Value);

                            if (validation != null)
                            {
                                description = $"Conversion {conversion.Name}. Parameter with name {v.Key}. {validation}";
                                return false;
                            }
                        }

                        usedInput.Add(inp);
                    }
                    else
                    {
                        description = $"Conversion {action.Name}. Input file with alias {inp}. Not provided and not generated by previous steps.";
                        return false;
                    }
                }

                FileDefinition actionOutput = action.OutputFormat(item.Input.Select(i => inputs[i]).ToArray(), item.Conversion.Values);
                item.ValidatedHash = actionOutput.Etag;

                if (!inputs.ContainsKey(item.Output))
                {
                    inputs.Add(item.Output, actionOutput);
                }
            }

            ConversionStep last = pipeline.Steps.Last();

            string id = last.Output;
            string etag = pipeline.Steps.Last().ValidatedHash;

            var ignoredInput = inputs.Keys.Where(k => !usedInput.Contains(k) && id != k).ToArray();

            if (ignoredInput.Any())
            {
                description = $"Inputs file with alias {string.Join(", ", ignoredInput)}. Not used in any conversion";
                return false;
            }

            output = new FileDefinition(id, etag, inputs[id].Format);

            return true;
        }
    }
}
